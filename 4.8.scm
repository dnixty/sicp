(define (eval exp env)
  (cond ((self-evaluating? exp)
         exp
         ((variable? exp)
          (lookup-variable-value exp env))
         ((quoted? exp)
          (text-of-quotation exp))
         ((assignment? exp)
          (eval-assignment exp env))
         ((definition? exp)
          (eval-definition exp env))
         ((if? exp)
          (eval-if exp env))
         ((lambda? exp)
          (make-procedure
           (lambda-parameters exp)
           (lambda-body exp)
           env))
         ((let? exp)
          (eval (let->combination exp) env))
         ((begin? exp)
          (eval-sequence
           (begin-actions exp)
           env))
         ((cond? exp)
          (eval (cond->if exp) env))
         ((application? exp)
          (apply (eval (operator exp) env)
                 (list-of-values
                  (operands exp)
                  env)))
         (else
          (error "Unknwon expression type: EVAL" exp)))))

(define (make-begin seq) (cons 'begin seq))

(define (let? exp) (tagged-list? exp 'let))
(define (let-definitions exp) (cadr exp))
(define (let-body exp) (cddr exp))
(define (named-let-name exp) (cadr exp))
(define (named-let-bindings exp) (caddr exp))
(define (named-let-body exp) (cadddr exp))
(define (named-let? exp) (symbol? (cadr exp)))
(define (let->combination exp)
  (if (named-let? exp)
      (expand-named-let (named-let-name exp)
                        (named-let-definitions exp)
                        (named-let-body exp))
      (expand-let (let-definitions exp) (let-body exp))))
(define (expand-let definitions body)
  (let ((vars (map car definitions))
        (exps (map cadr definitions)))
    (cons (make-lambda vars body) exps)))
(define (expand-named-let name bindings body)
  (let ((params (map car bindings))
        (initials (map cadr bindings)))
    (make-begin
     (list
      (list 'define (cons name params) body)
      (cons name initials)))))

;; Test
(define e '(let fib-iter ((a 1) (b 0) (count 2)) (+ a b count)))
(let->combination e)
